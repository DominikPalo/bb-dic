{"version":3,"sources":["../src/dic.js"],"names":["_","require","Joi","Parser","Dic","options","attempt","object","keys","containerSeparator","string","optional","default","debug","boolean","ecmaVersion","number","stripUnknown","presence","instances","parent","parentOptions","children","parser","msg","console","log","getDicInstanceName","name","factory","opts","register","defaults","type","asyncFactory","registerAsyncFactory","arguments","registerFactory","ins","instance","registerInstance","classDef","class","registerClass","def","ret","findContainer","throwError","container","validateDef","childName","child","asyncInit","getAsync","stack","separator","indexOf","split","serviceName","cont","parentName","stackStr","join","Error","_createOpts","loc","get","asyncInitialized","ignoreAsync","createInstance","hasAsyncInit","isUndefined","warn","initPromise","_getAsyncResolve","createInstanceAsync","initMethod","isString","getAsyncInitDef","alias","has","serviceLoc","destLoc","dic","required","bindContainer","_getServices","instanceCreated","_getServicesAsync","factoryListener","inject","paramsAlias","parseClass","init","params","ret1","parseFunction","ret2","_getDefParams","map","param","push","service","instanceOpts","cloneDeep","module","exports"],"mappings":"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","file":"dic.js","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Joi = require('joi');\nconst Parser = require('./parser');\n\n/**\n * Dependency injection container\n *\n * For more usage examples see: {@link Dic#instance}, {@link Dic#class}, {@link Dic#factory},\n * {@link Dic#asyncFactory}, {@link Dic#bind}.\n *\n * @example // Dependency injection example\n * class MyService {\n *   constructor(myServiceOpts) {\n *     this.options = myServiceOpts;\n *   }\n * }\n *\n * const {Dic} = require('@kapitchi/bb-dic');\n * const dic = new Dic();\n *\n * dic.instance('myServiceOpts', { some: 'thing' });\n *\n * const myService = dic.get('myService');\n *\n */\nclass Dic {\n\n  /**\n   * @param {Object} [options]\n   * @param {String} [options.containerSeparator=_] Container / service name separator. See {@link Dic#bind}\n   * @param {boolean} [options.debug=false] Debug on/off.\n   * @param {number} [options.ecmaVersion=8] ECMAScript version.\n   */\n  constructor(options) {\n    this.options = Joi.attempt(options || {}, Joi.object().keys({\n      containerSeparator: Joi.string().optional().default('_'),\n      debug: Joi.boolean().optional().default(false),\n      ecmaVersion: Joi.number().optional().default(8)\n    }).options({\n      stripUnknown: true,\n      presence: 'required'\n    }));\n    this.instances = {};\n    this.parent = null;\n    this.parentOptions = {};\n    this.children = {};\n\n    this.parser = new Parser({\n      ecmaVersion: this.options.ecmaVersion\n    });\n  }\n\n  log(msg) {\n    if (this.options.debug) {\n      console.log(`${this.getDicInstanceName()}: ${msg}`);\n    }\n  }\n\n  /**\n   * Registers async factory.\n   *\n   * Factory function is called asynchronously and should return an instance of the service.\n   *\n   * @alias Dic#asyncFactory\n\n   * @example\n   * dic.instance('mongoConnectionOpts', { url: 'mongodb://localhost:27017/mydb' });\n   * dic.asyncFactory('mongoConnection', async function(mongoConnectionOpts) {\n   *   return await MongoClient.connect(mongoConnectionOpts.url);\n   * });\n   *\n   * @param {String} name\n   * @param {Function} factory\n   * @param {defOpts} [opts]\n   */\n  registerAsyncFactory(name, factory, opts = {}) {\n    this.log(`Adding async factory \"${name}\" Options: `, opts);//XXX\n\n    this.register(name ,_.defaults({\n      type: 'asyncFactory',\n      asyncFactory: factory\n    }, opts));\n  }\n\n  asyncFactory() {\n    return this.registerAsyncFactory(...arguments);\n  }\n\n  /**\n   * Register a factory.\n   *\n   * The factory function should return an instance of the service.\n   *\n   * @alias Dic#factory\n   *\n   * @example\n   * dic.instance('myServiceOpts', { some: 'thing' })\n   * dic.factory('myService', function(myServiceOpts) {\n   *   return new MyService(myServiceOpts);\n   * });\n   *\n   * @param name\n   * @param factory\n   * @param {defOpts} [opts]\n   */\n  registerFactory(name, factory, opts = {}) {\n    this.log(`Adding factory \"${name}\" Options: `, opts);//XXX\n\n    this.register(name, _.defaults({\n      factory: factory\n    }, opts));\n  }\n\n  factory() {\n    return this.registerFactory(...arguments);\n  }\n\n  /**\n   * Register an instance\n   *\n   * @alias Dic#instance\n   *\n   * @example\n   *\n   * dic.instance('myScalarValue', 'string');\n   * dic.instance('myObject', { some: 'thing' });\n   * dic.instance('myFunction', function(msg) { console.log(msg) });\n   *\n   * @param name\n   * @param instance\n   */\n  registerInstance(name, ins, opts = {}) {\n    this.log(`Adding instance \"${name}\" Options: `, opts);//XXX\n\n    this.register(name, _.defaults({\n      instance: ins\n    }, opts));\n  }\n\n  instance() {\n    return this.registerInstance(...arguments);\n  }\n\n  /**\n   * Register a class\n   *\n   * @alias Dic#class\n   *\n   * @example // Class instance registration with dependency injection\n   *\n   * class MyService {\n   *   constructor(myServiceOpts) {\n   *     this.options = myServiceOpts;\n   *   }\n   * }\n   *\n   * dic.instance('myServiceOpts', {\n   *   some: 'options'\n   * })\n   * dic.class('myService', MyService)\n   *\n   * @example // Class instance registration with default async init function\n   *\n   * class MyService {\n   *   // optional async initialization of an instance\n   *   async asyncInit() {\n   *     //some async initialization e.g. open DB connection.\n   *   }\n   * }\n   *\n   * dic.class('myService', MyService)\n   *\n   * @example // Custom async init function\n   *\n   * class MyService {\n   *   async otherAsyncInitFn() {\n   *     //...\n   *   }\n   * }\n   *\n   * dic.class('myService', MyService, {\n   *   asyncInit: 'otherAsyncInitFn'\n   * })\n   *\n   * @param name\n   * @param classDef\n   * @param {defOpts} [opts]\n   */\n  registerClass(name, classDef, opts = {}) {\n    this.log(`Adding class \"${name}\" Options: `, opts);//XXX\n\n    this.register(name, _.defaults({\n      class: classDef\n    }, opts));\n  }\n\n  class() {\n    return this.registerClass(...arguments);\n  }\n\n  register(name, def) {\n    const ret = this.findContainer(name);\n\n    if (ret.def) {\n      this.throwError(`Service \"${name}\" already registered`);\n    }\n    def.name = name;\n    def.container = this;\n    ret.container.instances[ret.name] = this.validateDef(def);\n  }\n\n  /**\n   * Runs async initialization of container services.\n   *\n   * This includes instances registered using:\n   *\n   *  - {@link Dic#asyncFactory}\n   *  - {@link Dic#class} a class having `async asyncInit()` method or with async init option set\n   *\n   *  @example\n   *  dic.asyncInit().then(() => {\n   *    // your services should be fully instantiated.\n   *  }, err => {\n   *    // async initialization of some service thrown an error.\n   *    console.error(err);\n   *  });\n   */\n  async asyncInit() {\n    this.log(`asyncInit started ...`);//XXX\n\n    for (const childName in this.children) {\n      const child = this.children[childName];\n      await child.asyncInit();\n    }\n\n    for (const name in this.instances) {\n      const def = this.instances[name];\n      if (def.type === 'asyncFactory' || def.asyncInit) {\n        await this.getAsync(name, {\n          stack: []\n        });\n      }\n    }\n\n    this.log(`asyncInit finished.`);//XXX\n  }\n\n  /**\n   * Returns true if a service is registered with a container\n   *\n   * @param name\n   * @returns {boolean}\n   */\n  has(name) {\n    const ret = this.findContainer(name);\n    return ret && ret.def;\n  }\n\n  findContainer(name) {\n    const separator = this.options.containerSeparator;\n    const def = this.instances[name];\n    if (def) {\n      return {\n        container: this,\n        name: name,\n        def: def\n      }\n    }\n\n    if (name.indexOf(separator) !== -1) {\n      const [childName, serviceName] = name.split(separator);\n      const cont = this.children[childName];\n      if (cont) {\n        if (cont.instances[serviceName]) {\n          return {\n            container: cont,\n            name: serviceName,\n            def: cont.instances[serviceName]\n          };\n        }\n        return {\n          container: cont,\n          name: serviceName\n        }\n      }\n    }\n\n    if (this.parent) {\n      const parentName = this.parentOptions.name + separator + name;\n      if (this.parent.instances[parentName]) {\n        return {\n          container: this.parent,\n          name: parentName,\n          def: this.parent.instances[parentName]\n        };\n      }\n    }\n\n    return {\n      container: this,\n      name: name\n    };\n  }\n\n  getDicInstanceName() {\n    if (this.parent) {\n      return this.parent.getDicInstanceName() + '.' + this.parentOptions.name;\n    }\n\n    return 'Dic';\n  }\n\n  throwError(msg, stack) {\n    let stackStr = '';\n    if (stack) {\n      stackStr = '[' + stack.join(' > ') + ']';\n    }\n    throw new Error(`${this.getDicInstanceName()}: ${msg} ${stackStr}`);\n  }\n\n  /**\n   * Get an instance.\n   *\n   * Throws an error if instance needs to be async initialized and is not yet.\n   *\n   * @example\n   * const myService = dic.get('myService');\n   *\n   * @param {String} name\n   * @returns {*}\n   */\n  get(name, opts = {}) {\n    opts = this._createOpts(name, opts);\n    const def = this.instances[name];\n    if (!def) {\n      const loc = this.findContainer(name);\n      if (!loc.def) {\n        this.throwError(`Instance \"${name}\" not defined`, opts.stack);\n      }\n      return loc.container.get(loc.name);\n    }\n\n    if (def.type === 'asyncFactory' && !def.asyncInitialized) {\n      this.throwError(`Async factory for ${name} must be run first. Run dic.asyncInit()`, opts.stack);\n    }\n\n    if (!opts.ignoreAsync && def.asyncInit && !def.asyncInitialized) {\n      this.throwError(`Instance \"${name}\" is not async initialized yet`, opts.stack);\n    }\n\n    if (def.instance) {\n      return def.instance;\n    }\n\n    const instance = this.createInstance(def, opts);\n\n    //test for possible init method but without init enabled\n    if (this.hasAsyncInit(instance)) {\n      if (_.isUndefined(def.asyncInit)) {\n        this.throwError(`${name} has got ${name}.asyncInit() method. Did you forget to mark this instance to be async initialized?`, opts.stack);\n      } else if (!def.asyncInit) {\n        console.warn(`${name} has got ${name}.asyncInit() method but auto init is disabled. Make sure you init the service manually yourself.`);\n      }\n    }\n\n    def.instance = instance;\n    return instance;\n  }\n\n  /**\n   * Get an instance.\n   *\n   * Async initialize the instance if it's not yet.\n   *\n   * @example // Async/await\n   * const myService = await dic.get('myService');\n   *\n   * @example // Promise\n   * dic.getAsync('myService').then(myService => {\n   *   // ...\n   * });\n   *\n   * @param {String} name\n   * @returns {*}\n   */\n  async getAsync(name, opts = {}) {\n    opts = this._createOpts(name, opts);\n    const def = this.instances[name];\n    if (!def) {\n      const loc = this.findContainer(name);\n      if (!loc.def) {\n        this.throwError(`Instance \"${name}\" not defined`, opts.stack);\n      }\n      return await loc.container.getAsync(loc.name, opts);\n    }\n\n    if (def.instance) {\n      return def.instance;\n    }\n\n    //make sure that async service can be resolved once only and return same promise\n    // => only first call resolves the service for DIC\n    if(def.initPromise) {\n      return def.initPromise;\n    }\n\n    return def.initPromise = this._getAsyncResolve(name, def, opts);\n  }\n\n  async _getAsyncResolve(name, def, opts) {\n    const instance = await this.createInstanceAsync(def, opts);\n    if (def.asyncInit) {\n      let initMethod = 'asyncInit';\n      if (_.isString(def.asyncInit)) {\n        initMethod = def.asyncInit;\n      }\n      this.log(`Async init: ${name}.${initMethod}()`);\n      await instance[initMethod]();\n    }\n\n    def.instance = instance;\n    def.asyncInitialized = true;\n    return instance;\n  }\n\n  hasAsyncInit(instance) {\n    return !!this.getAsyncInitDef(instance);\n  }\n\n  getAsyncInitDef(instance) {\n    return instance.asyncInit ? 'asyncInit' : false;\n  }\n\n  /**\n   * Creates an alias for existing container instance.\n   *\n   * @example\n   * dic.instance('one', {some: 'instance'});\n   * dic.alias('one', 'oneAgain');\n   *\n   * dic.get('one') === dic.get('oneAgain')\n   *\n   * @param {String} name An instance to be aliased\n   * @param {String} alias Alias\n   */\n  alias(name, alias) {\n    this.log(`aliasing \"${alias}\" -> \"${name}\"`);//XXX\n    if (!this.has(name)) {\n      this.throwError(`Service \"${name}\" is not registered`);\n    }\n    if (this.has(alias)) {\n      this.throwError(`Cannot use alias \"${alias}\". Service with this name is registered already.`);\n    }\n    const serviceLoc = this.findContainer(name);\n    const destLoc = this.findContainer(alias);\n    destLoc.container.instances[destLoc.name] = serviceLoc.container.instances[serviceLoc.name];\n  }\n\n  /**\n   * Bind other Dic instance with this one.\n   *\n   * @example\n   * // -----------------------------------------\n   * // my-package.js - reusable package\n   * // -----------------------------------------\n   * const {Dic} = require('@kapitchi/bb-dic');\n   *\n   * class Logger {\n   *   log(msg) {\n   *     console.log('MyLogger: ' + msg);\n   *   }\n   * }\n   *\n   * const dic = new Dic();\n   * dic.instance('logger', Logger);\n   *\n   * module.exports = dic;\n   *\n   * // -----------------------------------------\n   * // my-application.js - an application itself\n   * // -----------------------------------------\n   * const {Dic} = require('@kapitchi/bb-dic');\n   * const packageDic = require('./my-package');\n   *\n   * class MyService() {\n   *   constructor(myPackage_logger) {\n   *     // injected logger instance\n   *     this.logger = myPackage_logger;\n   *   }\n   *\n   *   sayHello(msg) {\n   *     this.logger.log(msg);\n   *   }\n   * }\n   *\n   * const dic = new Dic();\n   * dic.class('myService', MyService);\n   *\n   * dic.bind(packageDic, {\n   *   name: 'myPackage'\n   * })\n   *\n   * // get a child service instance directly\n   * const logger = dic.get('myPackage_logger');\n   *\n   * @alias Dic#bind\n   *\n   * @param {Dic} dic\n   * @param {Object} opts\n   * @param {String} opts.name Container services prefix name\n   */\n  bindContainer(dic, opts = {}) {\n    opts = Joi.attempt(opts, {\n      name: Joi.string().required()\n    });\n\n    dic.parent = this;\n    dic.parentOptions = opts;\n\n    this.children[opts.name] = dic;\n  }\n\n  bind(dic, opts = {}) {\n    this.bindContainer(dic, opts);\n  }\n\n  getBoundContainer(name) {\n    if (!this.children[name]) {\n      this.throwError(`${name} child container does not exist`);\n    }\n\n    return this.children[name];\n  }\n\n  /**\n   * Create an instance injecting it's dependencies from the container\n   *\n   * @example\n   * class MyClass {\n   *   constructor(myClassOpts, someService) {\n   *   }\n   * }\n   *\n   * dic.instance('myClassOpts', { my: 'options' });\n   * dic.instance('someService', { real: 'service' });\n   *\n   * const ins = dic.createInstance({\n   *   class: MyClass,\n   *   inject: {\n   *     // myClassOpts - injected from dic\n   *     // someService - the below is injected instead of dic registered 'someService'.\n   *     someService: { mock: 'service' }\n   *   }\n   * })\n   *\n   * @param {Object} def\n   * @param {function} def.factory Factory function\n   * @param {function} def.class Class constructor\n   * @param {Object} def.inject\n   * @param {Object} opts\n   * @returns {*}\n   */\n  createInstance(def, opts) {\n    def = this.validateDef(def);\n\n    let ins;\n    switch(def.type) {\n      case 'asyncFactory':\n        this.throwError('Use dic.createInstanceAsync() instead', opts.stack);\n        break;\n      case 'factory':\n        ins = def.factory(...(this._getServices(def, opts)));\n        break;\n      case 'class':\n        ins = new (def.class)(...(this._getServices(def, opts)));\n        break;\n      default:\n        this.throwError(`Unknown instance def type: ${def.type}`, opts.stack);\n    }\n\n    return this.instanceCreated(ins, def);\n  }\n\n  /**\n   * Create an instance (async) injecting it's dependencies from the container.\n   *\n   * See {@link Dic#createInstance}\n   *\n   * @param {Object} def\n   * @param {function} def.asyncFactory Async function\n   * @param {function} def.factory Factory function\n   * @param {function} def.class Class constructor\n   * @param {Object} def.inject\n   * @param {Object} opts\n   * @returns {*}\n   */\n  async createInstanceAsync(def, opts) {\n    def = this.validateDef(def);\n\n    let ins;\n    switch(def.type) {\n      case 'asyncFactory':\n        ins = await def.asyncFactory(...(await this._getServicesAsync(def, opts)));\n        break;\n      case 'factory':\n        ins = def.factory(...(await this._getServicesAsync(def, opts)));\n        break;\n      case 'class':\n        ins = new (def.class)(...(await this._getServicesAsync(def, opts)));\n        break;\n      default:\n        this.throwError(`Unknown instance def type: ${def.type}`, opts.stack);\n    }\n\n    return this.instanceCreated(ins, def);\n  }\n\n  instanceCreated(ins, def) {\n    if (this.factoryListener) {\n      return this.factoryListener(ins, def);\n    }\n\n    return ins;\n  }\n\n  /**\n   * @typedef {Object} defOpts\n   * @property {string|boolean} [asyncInit] If true default asyncInit() function is used. If string, provided function is called on {@link Dic#asyncInit}.\n   * @property {Object} [paramsAlias] Use to alias class constructor or factory parameters.\n   * E.g. `{ serviceA: 'serviceB' }` injects `serviceB` instance instead of `serviceA` to the class constructor/factory.\n   */\n  validateDef(def) {\n    // def = Joi.attempt(def, Joi.object().keys({\n    //   name: Joi.string(),\n    //   type: Joi.string(),\n    //   instance: Joi.any(),\n    //   class: Joi.func(),\n    //   factory: Joi.func(),\n    //   asyncInit: Joi.any(),\n    //   params: Joi.array(),\n    //   paramsAlias: Joi.object().default({}),\n    //   asyncFactory: Joi.func(),\n    //   inject: Joi.object().default({}),\n    //   container: Joi.object().default(this) //type(Dic) - this does not work when having Dic from different packages obviously\n    // }).options({\n    //   allowUnknown: true //e.g. asyncInitialized\n    // }));\n\n    if (!def.instance && !def.class && !def.factory && !def.asyncFactory) {\n      throw new Error('One of [instance, class, factory, asyncFactory] must be defined');\n    }\n\n    if (!def.type) {\n      for (const type of ['class', 'factory', 'asyncFactory', 'instance']) {\n        if (def[type]) {\n          def.type = type;\n        }\n      }\n    }\n\n    def.inject = def.inject || {};\n    def.paramsAlias = def.paramsAlias || {};\n    def.container = def.container || this;\n\n    if (def.type === 'class') {\n      if (_.isUndefined(def.asyncInit)) {\n        const ret = this.parser.parseClass(def.class);\n        if (ret.init) {\n          def.asyncInit = ret.init.name;\n        }\n      }\n    }\n\n    if (!def.params) {\n      switch (def.type) {\n        case 'instance':\n          break;\n        case 'asyncFactory':\n        case 'factory':\n          const ret1 = this.parser.parseFunction(def.factory || def.asyncFactory);\n          def.params = ret1.params;\n          break;\n        case 'class':\n          const ret2 = this.parser.parseClass(def.class);\n          if (ret2.factory.type !== 'ClassConstructor') {\n            this.throwError('Could not find a constructor def');\n          }\n          def.params = ret2.factory.params;\n          break;\n        default:\n          this.throwError(`Unknown instance def type: ${def.type}`);\n      }\n    }\n\n    return def;\n  }\n\n  _getServices(def, opts = {}) {\n    const {container} = def;\n    const params = this._getDefParams(def);\n    return params.map((param) => {\n      if (def.inject[param]) {\n        return def.inject[param];\n      }\n      return container.get(param, opts);\n    });\n  }\n\n  async _getServicesAsync(def, opts = {}) {\n    const {container} = def;\n    const params = this._getDefParams(def);\n\n    const ret = [];\n    for (const param of params) {\n      if (def.inject && def.inject[param]) {\n        ret.push(def.inject[param]);\n        continue;\n      }\n      ret.push(await container.getAsync(param, opts));\n    }\n\n    return ret;\n  }\n\n  _getDefParams(def) {\n    return def.params.map((param) => {\n      return _.get(def.paramsAlias, param, param);\n    })\n  }\n\n  _createOpts(service, opts) {\n    const instanceOpts = _.cloneDeep(opts);\n    let stack = _.get(instanceOpts, 'stack');\n    if (!stack) {\n      stack = [service ? service : '$this'];\n    } else {\n      stack.push(service);\n    }\n    instanceOpts.stack = stack;\n    return instanceOpts;\n  }\n\n}\n\nmodule.exports = Dic;\n"]}