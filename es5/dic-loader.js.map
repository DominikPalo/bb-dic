{"version":3,"sources":["../src/dic-loader.js"],"names":["_","require","nodePath","globby","DicLoader","opts","options","defaults","rootDir","process","cwd","debug","dic","path","prefix","postfix","removeDuplicate","ret","sync","relPath","absPath","mod","isObject","__esModule","default","basename","type","name","typeMatch","match","pathParts","split","sep","pop","push","spacedPath","join","replace","unshift","camelCase","console","log","class","asyncFactory","factory","instance","Error","module","exports"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAMA,IAAIC,QAAQ,QAAR,CAAV;AACA,IAAMC,WAAWD,QAAQ,MAAR,CAAjB;AACA,IAAME,SAASF,QAAQ,QAAR,CAAf;;AAEA;;;;;;;;;;;;;;;;IAeMG,S;AACJ;;;;AAIA,uBAAuB;AAAA,QAAXC,IAAW,uEAAJ,EAAI;AAAA;;AACrB,SAAKC,OAAL,GAAeN,EAAEO,QAAF,CAAWF,IAAX,EAAiB;AAC9BG,eAASC,QAAQC,GAAR,EADqB;AAE9BC,aAAO;AAFuB,KAAjB,CAAf;AAID;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA6BSC,G,EAAKC,I,EAAiB;AAAA,UAAXR,IAAW,uEAAJ,EAAI;;AAC7BL,QAAEO,QAAF,CAAWF,IAAX,EAAiB;AACfS,gBAAQ,EADO;AAEfC,iBAAS,EAFM;AAGfC,yBAAiB;AAHF,OAAjB;;AAMA,UAAMR,UAAUH,KAAKG,OAAL,GAAeH,KAAKG,OAApB,GAA8B,KAAKF,OAAL,CAAaE,OAA3D;;AAEA,UAAMS,MAAMd,OAAOe,IAAP,CAAYL,IAAZ,EAAkB;AAC5BH,aAAKF;AADuB,OAAlB,CAAZ;AAT6B;AAAA;AAAA;;AAAA;AAY7B,wDAAsBS,GAAtB,4GAA2B;AAAA,cAAhBE,OAAgB;;AACzB,cAAMC,UAAUZ,UAAU,GAAV,GAAgBW,OAAhC;AACA,cAAIE,MAAMpB,QAAQmB,OAAR,CAAV;;AAEA;AACA,cAAIpB,EAAEsB,QAAF,CAAWD,GAAX,KAAmBA,IAAIE,UAAvB,IAAqCF,IAAIG,OAA7C,EAAsD;AACpDH,kBAAMA,IAAIG,OAAV;AACD;;AAED,cAAMC,WAAWvB,SAASuB,QAAT,CAAkBN,OAAlB,EAA2B,KAA3B,CAAjB;;AAEA,cAAIO,OAAO,OAAX;AACA,cAAIC,OAAQF,QAAZ;;AAEA,cAAMG,YAAYH,SAASI,KAAT,CAAe,yCAAf,CAAlB;AACA,cAAID,SAAJ,EAAe;AACbD,mBAAOC,UAAU,CAAV,CAAP;AACAF,mBAAOE,UAAU,CAAV,CAAP;AACD;;AAED,cAAIE,YAAYX,QAAQY,KAAR,CAAc7B,SAAS8B,GAAvB,CAAhB;AACAF,oBAAUG,GAAV;AACAH,oBAAUI,IAAV,CAAeP,IAAf;;AAEA,cAAItB,KAAKW,eAAT,EAA0B;AACxB,gBAAImB,aAAaL,UAAUM,IAAV,CAAe,GAAf,CAAjB;AACAD,yBAAaA,WAAWE,OAAX,CAAmB,qBAAnB,EAA0C,IAA1C,CAAb;AACAP,wBAAYK,WAAWJ,KAAX,CAAiB,GAAjB,CAAZ;AACD;;AAED,cAAI1B,KAAKS,MAAT,EAAiB;AACfgB,sBAAUQ,OAAV,CAAkBjC,KAAKS,MAAvB;AACD;;AAED,cAAIT,KAAKU,OAAT,EAAkB;AAChBe,sBAAUI,IAAV,CAAe7B,KAAKU,OAApB;AACD;;AAEDY,iBAAO3B,EAAEuC,SAAF,CAAYT,UAAUM,IAAV,CAAe,GAAf,CAAZ,CAAP;AACA,cAAI,KAAK9B,OAAL,CAAaK,KAAjB,EAAwB;AACtB6B,oBAAQC,GAAR,iBAA0Bd,IAA1B,UAAmCD,IAAnC,aAA+CN,OAA/C;AACD;;AAED,kBAAOM,IAAP;AACE,iBAAK,OAAL;AACEd,kBAAI8B,KAAJ,CAAUf,IAAV,EAAgBN,GAAhB;AACA;AACF,iBAAK,eAAL;AACET,kBAAI+B,YAAJ,CAAiBhB,IAAjB,EAAuBN,GAAvB;AACA;AACF,iBAAK,SAAL;AACET,kBAAIgC,OAAJ,CAAYjB,IAAZ,EAAkBN,GAAlB;AACA;AACF,iBAAK,UAAL;AACET,kBAAIiC,QAAJ,CAAalB,IAAb,EAAmBN,GAAnB;AACA;AACF;AACE,oBAAM,IAAIyB,KAAJ,WAAkBpB,IAAlB,oBAAN;AAdJ;AAgBD;AAvE4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwE9B;;;;;AAGHqB,OAAOC,OAAP,GAAiB5C,SAAjB","file":"dic-loader.js","sourcesContent":["const _ = require('lodash');\nconst nodePath = require('path');\nconst globby = require('globby');\n\n/**\n * Dic loader\n *\n * @example // Registers all classes/factories/instances under `__dirname/src` folder.\n *\n * const {Dic, DicLoader} = require('@kapitchi/bb-dic');\n * const dic = new Dic();\n *\n * const loader = new DicLoader({\n *   rootDir: __dirname + '/src' //if not specified process.cwd() is used by default\n * });\n * loader.loadPath(dic, '*.js');\n *\n * module.exports = dic;\n */\nclass DicLoader {\n  /**\n   * @param {Object} opts\n   * @param {string} opts.rootDir Absolute path to root folder of source files. Default: `process.cwd()`\n   */\n  constructor(opts = {}) {\n    this.options = _.defaults(opts, {\n      rootDir: process.cwd(),\n      debug: false\n    });\n  }\n\n  /**\n   * Load all instances/factories/classes to {@link Dic}.\n   *\n   * File types and what they should export\n   * - name.js -> class\n   * - name.factory.js -> factory\n   * - name.async-factory.js -> async factory\n   * - name.instance.js -> instance\n   *\n   *\n   * File name dictates what name the service will be registered as.\n   * E.g. `my-service.js` service would become registered as `myService` => file name is camelCased.\n   *\n   * `opts.removeDuplicate` option\n   * If false, `user/user-service.js` would normally be aliased as `userUserService`.\n   * If true, this would be work like examples below:\n   * - `user/user-service.js` -> `userService`\n   * - `user-service/user-service.js` -> `userService`\n   * - `user-service/user-repository.js` -> `userServiceUserRepository`\n   * - `users/user-service.js` -> `usersUserService`\n   *\n   * @param {Dic} dic\n   * @param {string|string[]} path glob expression {@link https://www.npmjs.com/package/globby}\n   * @param {Object} [opts]\n   * @param {string} [opts.prefix=''] Instance name prefix\n   * @param {string} [opts.postfix=''] Instance name postfix\n   * @param {string} [opts.removeDuplicate=false] If true, remove duplicated folder/file names as described above.\n   * @param {string} [opts.rootDir] Overwrites loader's rootDir option\n   */\n  loadPath(dic, path, opts = {}) {\n    _.defaults(opts, {\n      prefix: '',\n      postfix: '',\n      removeDuplicate: false\n    });\n\n    const rootDir = opts.rootDir ? opts.rootDir : this.options.rootDir;\n\n    const ret = globby.sync(path, {\n      cwd: rootDir\n    });\n    for (const relPath of ret) {\n      const absPath = rootDir + '/' + relPath;\n      let mod = require(absPath);\n\n      //es6 modules default export\n      if (_.isObject(mod) && mod.__esModule && mod.default) {\n        mod = mod.default;\n      }\n\n      const basename = nodePath.basename(relPath, '.js');\n\n      let type = 'class';\n      let name =  basename;\n\n      const typeMatch = basename.match(/(.*)\\.(factory|async-factory|instance)$/);\n      if (typeMatch) {\n        name = typeMatch[1];\n        type = typeMatch[2];\n      }\n\n      let pathParts = relPath.split(nodePath.sep);\n      pathParts.pop();\n      pathParts.push(name);\n\n      if (opts.removeDuplicate) {\n        let spacedPath = pathParts.join(' ');\n        spacedPath = spacedPath.replace(/\\b([\\w\\-]+)\\s+\\1\\b/g, '$1');\n        pathParts = spacedPath.split(' ');\n      }\n\n      if (opts.prefix) {\n        pathParts.unshift(opts.prefix);\n      }\n\n      if (opts.postfix) {\n        pathParts.push(opts.postfix);\n      }\n\n      name = _.camelCase(pathParts.join('-'));\n      if (this.options.debug) {\n        console.log(`DicLoader: ${name} [${type}] -> ${absPath}`);\n      }\n\n      switch(type) {\n        case 'class':\n          dic.class(name, mod);\n          break;\n        case 'async-factory':\n          dic.asyncFactory(name, mod);\n          break;\n        case 'factory':\n          dic.factory(name, mod);\n          break;\n        case 'instance':\n          dic.instance(name, mod);\n          break;\n        default:\n          throw new Error(`Type ${type} not supported`);\n      }\n    }\n  }\n}\n\nmodule.exports = DicLoader;\n"]}