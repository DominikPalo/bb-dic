{"version":3,"sources":["../src/parser.js"],"names":["_","require","acorn","loose","Parser","options","asyncInitMethodNames","target","isString","toString","node","parse","plugins","asyncawait","ecmaVersion","parseNode","e","console","log","fn","fnString","matches","match","Error","args","params","split","map","arg","replace","trim","filter","name","includes","type","body","ret","factory","methodNode","kind","getFunctionParams","value","isAsyncInitMethodName","key","generator","init","ret1","paramNode","module","exports"],"mappings":"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","file":"parser.js","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst acorn = require('acorn');\nconst loose = require('acorn/dist/acorn_loose');\n//const walk = require('acorn/dist/walk');\n\nrequire('acorn-es7-plugin')(acorn);\n\nclass Parser {\n  constructor(options) {\n    this.options = {\n      asyncInitMethodNames: ['asyncInit']\n    }\n  }\n\n  parseClass(target) {\n    if(!_.isString(target)) {\n      target = target.toString();\n    }\n\n    try {\n      //const node = loose.parse_dammit(target, {\n      const node = acorn.parse(target, {\n        //sourceType: 'script',\n        plugins: {\n          asyncawait: true\n        },\n        ecmaVersion: 7\n      });\n      return this.parseNode(node);\n    } catch(e) {\n      console.log('Failed to parse the class');//XXX\n      console.log(target);//XXX\n      console.log(e);//XXX\n      throw e;\n    }\n  }\n\n  parseFunction(fn) {\n    const fnString = fn.toString();\n    // First match everything inside the function argument parens.\n    let matches = fnString.match(/function\\s.*?\\(([^)]*)\\)/);\n    if(matches === null) {\n      //try arrow function (arg1, ...) =>\n      matches = fnString.match(/\\(([^)]*)\\)\\s*=>/);\n    }\n    if(!matches) {\n      throw new Error('Function with invalid format, only \"function()\" and \"() =>\" allowed');\n    }\n    const args = matches[1];\n\n    // Split the arguments string into an array comma delimited.\n    const params = args.split(',').map(function(arg) {\n      // Ensure no inline comments are parsed and trim the whitespace.\n      return arg.replace(/\\/\\*.*\\*\\//, '').trim();\n    }).filter(function(arg) {\n      // Ensure no undefined values are added.\n      return arg;\n    });\n\n    return {\n      params: params\n    }\n  }\n\n  isAsyncInitMethodName(name) {\n    return _.includes(this.options.asyncInitMethodNames, name);\n  }\n\n  parseNode(node) {\n    switch(node.type) {\n      case 'Program':\n        return this.parseNode(node.body[0]);\n        break;\n      case 'ClassDeclaration':\n        return this.parseNode(node.body);\n        break;\n      case 'ClassBody':\n        const ret = {\n          factory: {\n            type: 'ClassConstructor',\n            params: []\n          }\n        };\n        for (const methodNode of node.body) {\n          if(methodNode.type === 'MethodDefinition') {\n            if (methodNode.kind === 'constructor') {\n              ret.factory = {\n                type: 'ClassConstructor',\n                params: this.getFunctionParams(methodNode.value)\n              }\n            }\n\n            if (methodNode.kind === 'method') {\n              if (this.isAsyncInitMethodName(methodNode.key.name)) {\n                //TODO promises, etc etc?\n                let type = 'sync';\n                if (methodNode.value.generator) {\n                  type = 'generator';\n                // It looks like the plugin above strips \"methodNode.value.async\" async property at the end causing\n                // jsdoc2md to fail: \"Unable to parse .../bb-dic/src/parser.js: Unexpected token )\"\n                // https://www.npmjs.com/package/jsdoc-strip-async-await\n                //} else if (methodNode.value.async) {\n                } else if (methodNode.value['async']) {\n                  type = 'async';\n                }\n\n                ret.init = {\n                  name: methodNode.key.name,\n                  type: type\n                };\n              }\n            }\n          }\n        }\n        return ret;\n        break;\n      case 'FunctionDeclaration':\n        const ret1 = {};\n        ret1.factory = {\n          type: 'ClassConstructor',\n          params: this.getFunctionParams(node)\n        };\n        return ret1;\n      default:\n        console.log(node);//XXX\n        throw new Error(`Parser for type ${node.type} not implemented`);\n    }\n  }\n\n  getFunctionParams(node) {\n    if (!node.params) {\n      throw new Error('Node has got no params');\n    }\n\n    return node.params.map(paramNode => paramNode.name);\n  }\n\n}\n\nmodule.exports = Parser;\n"]}